# log_metrics 输出指南 (Output Guide)

本文档说明 `analyzer/log_metrics` 产生什么输出，以及这些输出应如何正确解读。

## 适用范围

该模块有两条实际输出路径。主路径是 `__main__.py` 与 `parse_metrics.py` 产生的图表输出，次路径是 `analysis.py` 与 `parse_metrics.py` 辅助函数产生的文本对比表。

---

## 1. CLI 的实际输出

主入口命令是 `python -m analyzer.log_metrics -l <log_dir> -o <output_dir> -m <metric1> <metric2> ...`。

对于 `-m` 中的每个指标，程序先执行 `GlobalMetricsStats.preprocessing` 预处理并在各节点目录写入 `metrics.pq` 缓存，再根据百分位选节点，绘制时序图，并保存一个 PDF 文件。

### 文件输出

缓存文件路径是 `<log_dir>/<node_ip>/metrics.pq`。图表文件路径是 `<output_dir>/<sanitized_metric_name>.pdf`。

### 终端输出

终端通常会出现多进程 `tqdm` 进度条，以及绘图前打印的 `paths_and_tags`。如果覆盖率不足，会输出警告：`警告: 在 <log_dir> 中仅找到 <valid>/<total> 个节点具有指标 <metric_name>`。触发条件是具有该指标的节点比例低于 80%。

---

## 2. 输入日志解析规则

解析器只处理符合 `<timestamp>, <module>, Group, {k1: v1, k2: v2, ...}` 结构的日志行。

约束较严格。`timestamp` 按整数毫秒处理，`module` 必须匹配 `[0-9a-z_]+`，指标值必须可解析为浮点数。不匹配的行会被静默跳过。因此输出的完整性和准确性直接依赖 `metrics.log` 是否满足该格式。

---

## 3. `.m1` 派生指标含义

在绘图和统计之前，预处理会为所有以 `.count` 结尾的指标生成 `<original>.m1`。这个 `.m1` 不是简单差分，而是“计数增量的时间衰减加权平均”。

计算过程分三步。

1. 先计算增量序列 `diff[i] = value[i] - value[i-1]`（首点保持原值）。
2. 再按时间间距（分钟尺度）构建指数衰减权重。
3. 最后输出每个时间戳对应的加权结果。

解读上应区分两者：`.count` 往往是累计计数，`.count.m1` 更接近平滑后的短期速率/吞吐信号。

---

## 4. 图例 `P0/P50/P100` 的真正含义

`plot_metrics_by_pecentiles` 采用双层百分位逻辑。

1. 节点内层：先对每个节点计算一个代表值，默认是该节点该指标的 `p90`（`node_percentile=90`）。
2. 节点间层：再按这个代表值在全网节点中排序，并按 `plot_percentiles`（默认 `[0,10,50,90,100]`）取对应位置节点。

因此图例 `P0/P50/P100` 表示“节点在全局排序中的位置桶”，不是“每个时刻的全网分位线”。这是本模块最关键的解读点。

---

## 5. 图表语义

图的 X 轴是墙上时钟时间（`HH:MM`），Y 轴是指标值且下界固定为 0。每个被选中的节点对应一条线，`extra_nodes` 会额外增加曲线。

单位处理由参数决定。默认保持日志原始单位；若 `nano_seconds=True`，数值会除以 `1e9` 并按秒 `s` 展示。时间过滤通过 `time_range="HH:MM-HH:MM"` 完成，采用本地时间并支持跨午夜区间。

---

## 6. 文本对比表输出

`analysis.py` 提供两个日志目录之间的比较输出。

`compare_logs(...)` 的表头是 `指标`、`倍数`、`基准值`、`对比值`，其中 `倍数 = compare / base`。其处理流程是：先在两个 run 中各选一个全局百分位节点（默认 `global_p=90`），再跳过缺失或为 0 的指标，最后按倍数降序输出，并先打印被跳过的指标名。

`parse_metrics.py` 中还有 `print_node_stats_table` 与 `print_global_stats_table` 两个格式化函数，用于打印节点级与全局级分位统计，但它们不会被 `__main__.py` 自动调用。

---

## 7. 指标命名与查询

查询既可以使用显式 `module::key`，也可以使用裸 `key`。不过裸 `key` 仅在该 key 在所有模块中唯一时才成立；若跨模块重名，会触发歧义异常。

为保证脚本稳定性与可复现性，建议始终使用 `module::key`。

---

## 8. 解读核对清单

阅读单个 PDF 时，建议按顺序检查以下问题。

1. 当前指标是原始 key 还是派生 `.m1`？
2. Y 轴单位是原始值还是纳秒转秒？
3. 图例 `P*` 是否按“节点排序桶”理解，而非时刻分位？
4. `valid/total` 覆盖率警告是否可接受？
5. 若结果异常，原始日志格式与模块/键命名是否满足解析规则？
